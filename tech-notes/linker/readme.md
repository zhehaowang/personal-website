# (Linker)[http://csapp.cs.cmu.edu/2e/ch7-preview.pdf]

Object files are bag of bits containing program data and code
* relocatable (.o generated by the compiler)
* executable (linker works with relocatable object files generated by the compiler to generate an executable)
* shared

Object file format on modern nix is ELF (executable and linkable format).

ELF format object files has
* header (word size, compiled machine endian)
* program header table
* text (program code)
* rodata (read-only data, the likes of printf format string)
* data (initialized vars)
* bss (uninitialized vars (i.e. zero initialized, like static vars), no need to take up space on disk, just say what and how much size is needed. Better Save Space)
* symtab (symbol table, present regardless of `-g`. function and global var defined and referenced. no local symbols (in the linker sense, not stack variables sense!) needed)
* rel.txt (relocatable text: reference to external functions, relocation required when linking. not present in the produced executable)
* rel.data (relocatable data: reference to external vars, relocation required when linking. not present in the produced executable)
* debug (produced only when `-g`, local symbols, global symbols, typedefs, original C source file)
* line (produced only when `-g`, mapping between C source program and machine code instruction in the text section)
* strtab (character strings for symbol tables in symtab and debug, and section names in section headers)
* section header table (describes object file sections)

As far as linker is concerned, there are
* global symbols: non static C functions and non-static global variables defined in this object file
* externals: global symbols referenced by this object file but defined elsewhere
* local symbols: defined and referenced exclusively by this object file (static C functions and static global vars)

Assemblers build symbol tables using symbols exported by the compiler into the assembly-language `.s` file.

A symbol table entry has
* name (int offset into string table)
* value (address: section offset in relocatable, or runtime virtual memory address in executable)
* size in bytes
* type (data, function, section or source file name)
* binding (local or global)
* section header index

The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol tables of its input relocatable object files.
* local symbol references, straightforward
* 

(Name mangling: C++ allows overloads with same name but different params list. how does the linker tell the difference? The compiler encodes each unique method and parameter list combination into a unique name for the linker, which is called mangling. Java and C++ use compatible name mangling schemes: `Foo::bar(int, long)` is encoded as `bar_3Fooil` (method name, mangled class name (size prepended), argument types))

##### Dealing with multiply defined symbols

At compile time, compiler exports each global symbol to the assembler as strong or weak, and the assembler encodes this info implicitly in the symbol table of the relocatable object file.
* Functions, initialized global vars get strong symbols
* Unitialized global vars get weak symbols

When linking
* Multiple strong symbols are not allowed
* Given a strong symbol and multiple weak symbols, choose the strong
* Given multiple weak symbols, choose any of the weak

Consider this code
```cpp
/* foo.c */
void f(void);
int x = 1;
int main() {
    f();
    // what's the value of x? it's 2!
    return 0;
}

/* bar.c */
int x;
void f(void) { x = 2; }
```

Even nastier
```cpp
/* foo.c */
void f(void);
int x = 1; // 4 bytes
int y = 1; // 4 bytes
int main() {
    f();
    // what's the value of x and y? 0x0 and 0x80000000
    return 0;
}

/* bar.c */
double x;
void f(void) { x = -0.0; }
```
Invoke the linker with `-fno-common` to catch multiply defined global symbols.

##### Linking with static library

When building the output executable, the linker copies only the object modules in the static library that are referenced by the application program.

Why static libraries?
Alternatives are implement std library functions in compiler, Pascal does this, but not practical for C's large number of library functions (also requires new compiler version each time new std function is implemented).
Or in individual relocatable object files, which would require explicitly listing them.

On Unix systems, static libraries are stored on disk in a particular file format known as an archive.
An archive is a collection of concatenated relocatable object files, with a header that describes the size and location of each member object file.


Check out `readelf`, `nm`, etc.

